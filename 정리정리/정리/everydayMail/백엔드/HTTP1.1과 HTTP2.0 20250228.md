## [HTTP/1.1과 HTTP/2.0에 대해서 설명해주세요.](https://www.maeil-mail.kr/question/130)

백엔드와 관련된 질문이에요.

## HTTP/1.1에 대해서 설명해주세요.

HTTP는 웹상에서 클라이언트와 서버 간 통신을 위한 프로토콜입니다. HTTP/1.0의 경우에는 한 개의 요청과 응답마다 TCP 커넥션을 생성하여 사용됐습니다. 하지만, 이러한 방식은 매 요청마다 연결을 생성하는 오버헤드가 발생합니다. **HTTP/1.1**은 이러한 문제를 **지속 커넥션(Persistent Connection)** 이라는 지정한 타임아웃만큼 커넥션을 종료하지 않는 방식으로 해결합니다.

또한 **파이프라이닝(Pipelining)** 을 지원하여 요청의 응답 지연을 감소합니다. 파이프라이닝에서 HTTP 요청은 연속적이며, 순차적으로 전달됩니다. 기존에는 요청한 이후에 응답을 기다리고 그 다음 요청을 보냈는데요. 파이프라이닝에서는 필요한 모든 자원에 대한 요청을 순차적으로 서버로 전송한 다음 모든 요청에 대한 응답을 한 번에 기다리게 됩니다.

HTTP/1.1은 1.0 버전에 비해 상당히 개선됐지만 여전히 문제가 존재하는데요. 대표적으로 **Head-of-Line Blocking(HOL Blocking) 문제**가 있습니다. 만약 3개의 요청을 파이프라인을 통해 전송을 한다고 했을 때, 서버는 모든 요청을 순서에 맞춰서 응답해야 합니다. 이때 첫 번째 요청이 오래 걸린다고 하면, 나머지 요청은 첫 번째 요청의 처리를 기다려야 합니다. 또한, 1.1 버전은 매 요청마다 **동일한 헤더를 반복하여 전송한다는 문제점**도 존재합니다.

## HTTP/2.0에 대해서 설명해주세요.

HTTT/1.1는 메시지를 일반 텍스트 형식으로 전송했습니다. 2.0부터는 기존 HTTP 메시지를 프레임이라는 단위로 분할하고 이를 바이너리 형태로 만들어서 전송합니다. 따라서, 기존 1.1 버전에 비해 파싱 및 전송 속도가 향상되었습니다.

또한, HTTP/2.0 부터는 **멀티플렉싱(Multiplexing)** 을 지원합니다. 이는 하나의 커넥션을 사용하여 요청과 응답을 병렬로 처리할 수 있는 방식입니다. 클라이언트가 서버로 여러 요청을 동시에 보내도 각 요청이 독립적으로 처리되기 때문에 애플리케이션 레이어의 HOL Blocking 문제를 해결합니다. 또한 **HPACK 헤더 압축 방식**을 사용해 반복되는 헤더를 효율적으로 관리하여 대역폭 사용이 최적화되었습니다.

## 추가 학습 자료를 공유합니다.ㅊ

- [웹 개발자라면 알고 있어야 할 HTTP의 진화 과정](https://yozm.wishket.com/magazine/detail/1686/)
- [gRPC 를 도입하는 이유에 대해서 알아보자 (feat. HTTP 1.0 vs HTTP 1.1 vs HTTP 2.0)](https://eottabom.github.io/post/why-using-grpc/)
- [[10분 테코톡] 🧃쿨라임의 HTTP/1.1, HTTP/2, 그리고 QUIC](https://youtu.be/xcrjamphIp4?feature=shared)
- [HTTP3까지 버전별 변천사와 동작원리](https://velog.io/@yesbb/HTTP3%EA%B9%8C%EC%A7%80-%EB%B2%84%EC%A0%84%EB%B3%84-%EB%B3%80%EC%B2%9C%EC%82%AC#2-tcp%EB%A0%88%EB%B2%A8%EC%97%90%EC%84%9C%EC%9D%98-holbhead-of-line-blocking-)